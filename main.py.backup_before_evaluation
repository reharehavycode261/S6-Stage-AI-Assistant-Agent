# -*- coding: utf-8 -*-
"""
Application principale FastAPI - VyData Agent.

Endpoints:
    - /webhook/monday: Webhook Monday.com
    - /health: Health check
    - /evaluation/run: D√©clencher l'√©valuation de l'agent
    - /evaluation/reports: Lister les rapports d'√©valuation
"""

from fastapi import FastAPI, Request, HTTPException, BackgroundTasks
from fastapi.responses import JSONResponse
from contextlib import asynccontextmanager
import uvicorn
from typing import Optional, Dict, Any

from config.settings import settings
from services.monday_webhook_service import process_monday_webhook
from services.evaluation.agent_evaluation_service import AgentEvaluationService
from models.evaluation_models import DatasetType, AgentEvaluationConfig
from utils.logger import get_logger

logger = get_logger(__name__)


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Gestion du cycle de vie de l'application."""
    logger.info("üöÄ D√©marrage de l'application VyData Agent...")
    logger.info(f"üìä Environment: {settings.environment}")
    logger.info(f"üîó Monday Board ID: {settings.monday_board_id}")
    yield
    logger.info("üõë Arr√™t de l'application VyData Agent...")


app = FastAPI(
    title="VyData Agent API",
    description="Agent IA conversationnel pour le d√©veloppement logiciel",
    version="2.0.0",
    lifespan=lifespan
)


# ============================================================================
# WEBHOOK MONDAY.COM
# ============================================================================

@app.post("/webhook/monday")
async def webhook_monday(request: Request):
    """
    Endpoint pour recevoir les webhooks de Monday.com.
    
    Traite:
    - Cr√©ation d'items
    - Modifications de colonnes
    - Nouveaux updates/commentaires (@vydata)
    """
    logger.info("=" * 80)
    logger.info("üåê REQU√äTE HTTP RE√áUE: POST /webhook/monday")
    logger.info("=" * 80)
    
    try:
        # R√©cup√©rer le payload
        payload = await request.json()
        
        logger.info("üîî C'EST UN WEBHOOK MONDAY.COM !")
        
        # Traiter le webhook
        result = await process_monday_webhook(payload)
        
        if result:
            logger.info("‚úÖ R√âPONSE: Status 200")
            return JSONResponse(content={"status": "success"}, status_code=200)
        else:
            logger.info("‚úÖ R√âPONSE: Status 400")
            return JSONResponse(
                content={"status": "error", "message": "Processing failed"},
                status_code=400
            )
    
    except Exception as e:
        logger.error(f"‚ùå Erreur traitement webhook: {e}", exc_info=True)
        return JSONResponse(
            content={"status": "error", "message": str(e)},
            status_code=500
        )


# ============================================================================
# HEALTH CHECK
# ============================================================================

@app.get("/health")
async def health_check():
    """Health check de l'application."""
    return {
        "status": "healthy",
        "service": "VyData Agent",
        "version": "2.0.0",
        "environment": settings.environment
    }


# ============================================================================
# √âVALUATION DE L'AGENT
# ============================================================================

@app.post("/evaluation/run")
async def run_evaluation(
    background_tasks: BackgroundTasks,
    dataset_type: Optional[str] = None,
    run_in_background: bool = True
):
    """
    D√©clenche l'√©valuation de l'agent sur un Golden Dataset.
    
    Args:
        dataset_type: Type de dataset ("questions" ou "commands"). 
                     Si None, √©value les deux.
        run_in_background: Ex√©cuter en arri√®re-plan (recommand√©)
        
    Returns:
        Status de l'√©valuation
    """
    logger.info("=" * 80)
    logger.info("üìä DEMANDE D'√âVALUATION DE L'AGENT")
    logger.info("=" * 80)
    
    # Valider le dataset_type
    valid_types = ["questions", "commands", None]
    if dataset_type and dataset_type not in ["questions", "commands"]:
        raise HTTPException(
            status_code=400,
            detail=f"dataset_type invalide. Attendu: {valid_types}"
        )
    
    # Cr√©er le service d'√©valuation
    config = AgentEvaluationConfig()
    evaluation_service = AgentEvaluationService(config=config)
    
    async def run_evaluation_task():
        """T√¢che d'√©valuation √† ex√©cuter."""
        try:
            if dataset_type:
                # √âvaluer un seul dataset
                dataset_enum = DatasetType(dataset_type)
                report = await evaluation_service.evaluate_dataset(
                    dataset_type=dataset_enum,
                    save_report=True
                )
                
                logger.info(
                    f"‚úÖ √âvaluation {dataset_type} termin√©e: "
                    f"{report.reliability_score}/100"
                )
            else:
                # √âvaluer les deux datasets
                reports = []
                
                for dt in DatasetType:
                    try:
                        report = await evaluation_service.evaluate_dataset(
                            dataset_type=dt,
                            save_report=True
                        )
                        reports.append(report)
                    except FileNotFoundError:
                        logger.warning(f"‚ö†Ô∏è Dataset {dt.value} non trouv√©, ignor√©")
                
                logger.info(f"‚úÖ √âvaluation compl√®te termin√©e: {len(reports)} datasets")
        
        except Exception as e:
            logger.error(f"‚ùå Erreur durant l'√©valuation: {e}", exc_info=True)
    
    if run_in_background:
        # Ex√©cuter en arri√®re-plan
        background_tasks.add_task(run_evaluation_task)
        
        return {
            "status": "started",
            "message": "√âvaluation lanc√©e en arri√®re-plan",
            "dataset_type": dataset_type or "all",
            "note": "Consultez les logs pour suivre la progression"
        }
    else:
        # Ex√©cuter imm√©diatement (bloquant)
        await run_evaluation_task()
        
        return {
            "status": "completed",
            "message": "√âvaluation termin√©e",
            "dataset_type": dataset_type or "all"
        }


@app.get("/evaluation/reports")
async def list_evaluation_reports():
    """
    Liste tous les rapports d'√©valuation disponibles.
    
    Returns:
        Liste des rapports avec m√©tadonn√©es
    """
    try:
        import json
        from pathlib import Path
        
        reports_dir = Path(__file__).parent / "data" / "evaluation_reports"
        
        if not reports_dir.exists():
            return {"reports": [], "total": 0}
        
        reports_list = []
        
        for report_file in sorted(reports_dir.glob("evaluation_*.json"), reverse=True):
            try:
                with open(report_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                
                reports_list.append({
                    "filename": report_file.name,
                    "report_id": data.get("report_id"),
                    "dataset_name": data.get("dataset_name"),
                    "dataset_type": data.get("dataset_type"),
                    "reliability_score": data.get("reliability_score"),
                    "reliability_status": data.get("reliability_status"),
                    "total_tests": data.get("total_tests"),
                    "tests_passed": data.get("tests_passed"),
                    "average_score": data.get("average_score"),
                    "evaluated_at": data.get("evaluation_started_at"),
                    "duration_seconds": data.get("total_duration_seconds")
                })
            
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Erreur lecture rapport {report_file.name}: {e}")
        
        return {
            "reports": reports_list,
            "total": len(reports_list)
        }
    
    except Exception as e:
        logger.error(f"‚ùå Erreur listing rapports: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/evaluation/reports/{report_id}")
async def get_evaluation_report(report_id: str):
    """
    R√©cup√®re un rapport d'√©valuation sp√©cifique.
    
    Args:
        report_id: ID du rapport
        
    Returns:
        Rapport d'√©valuation complet
    """
    try:
        import json
        from pathlib import Path
        
        reports_dir = Path(__file__).parent / "data" / "evaluation_reports"
        
        # Chercher le fichier correspondant
        for report_file in reports_dir.glob("evaluation_*.json"):
            with open(report_file, "r", encoding="utf-8") as f:
                data = json.load(f)
            
            if data.get("report_id") == report_id:
                return data
        
        raise HTTPException(status_code=404, detail=f"Rapport {report_id} non trouv√©")
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"‚ùå Erreur r√©cup√©ration rapport: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


# ============================================================================
# MAIN
# ============================================================================

if __name__ == "__main__":
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="info"
    )
